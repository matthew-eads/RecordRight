#See https://www.twilio.com/docs/quickstart/python/sms

I'm using virtualenv: see http://docs.python-guide.org/en/latest/dev/virtualenvs/
and I have a requirements file I'll try to keep up to date, so you can just 
pip install -r requirements.txt once you're in your venv

There seem to be two ways to use the API:
  1. Manually send/receive messages, we repeatedly 
     query the server for any incoming messages, and
     for each one, we process it, and manually send 
     a response.
  2. Create a server which will respond to HTTP requests, 
     a GET request from twilio will contain an SMS we are
     receiving, and then we send back a message to twilio.

Both are pretty simple, but I'm leaning towards working with 
the first method for now. It should be simple enough to switch though. 

EDIT: scratch that, on further research, it seems making some sort of server
is the best solution.

To make life easier, I've created Phone.py, which is a simple little script
to simulate sending/receiving texts. Basically, it connects with the 
Flask app Server.py on localhost. It then reads messages from stdin,
which it formats as a POST request and then sends them to the server,
and then prints the response. It tries to look just like the requests
that Twilio sends, so our server doesn't actually know if its sending 
messages to twilio, or just to our testing service. Because of this,
the server sends back xml responses, so we have to do a quick parsing of
the xml to make it a bit more readable.

--------------------------------------------------------------------------------
##Heroku Stuff

I've now set up a heroku app to handle this. From the root (RecordRight/, not RRSMS/),
you can `git subtree push --prefix RRSMS heroku master`, which should be all you need
to do. Navigating to record-right.herokuapp.com should show a brief error message,
but you should be able to text the twilio number and get an actual response.
`heroku logs` shows the logs
`heroku ps` should show whether or not anything is running,
if not `heroku scale web=1` should spin it up.
`heroku domains` will show where it lives, and `heroku open` will open it in a browser.
`heroku run bash` or `heroku run python` is a useful way to debug manually if needed.
All this requires installing heroku, but there are easy guides on their website.

Procfile tells heroku how to run the app - right now it just runs python Server.py,
but in the future there are much better ways to deploy it for ~~production~~.

--------------------------------------------------------------------------------

Heroku uses postgres, and unless we want to pay money, we'll have to roll with that.
Because we can't actually copy over a database, I wrote a handler in Server.py
for /update, which handles the POST'ing of new patient info, and saves it to the db.
The script update_db.py can then be used to update the heroku db, or the local postgres db.
To handle db migrations, alembic should work. Running `alembic revision -m "message"`
will create a template migration file, edit that to add new columns or whatever,
and then `alembic upgrade head` should do the rest. Of course you also need to 
propogate the changes in the models_test.py file, and throughout the other scripts.

--------------------------------------------------------------------------------

To manage changes to the db, we need POST/UPDATE behavior for the server,
more specifically, I've added to routes, /update and /add. The latter simply
processes a HTTP POST containing all the fields for a new patient, and inserts
into the db. /update handles a HTTP POST containing the patient id, and then
updates all ~specified~ additional fields for that patient. The scripts update_db.py
and add_db.py are command-line interfaces for these two. 

----------------------------------------------------------------------------------
Here is an enumeration of menu states:
0: New message from existing patient
1: Patient responds to welcome message - either asks to fetch or update
2: Fetch, message should contain field to retrieve
3: Update, message should contain field to update
4: Update, message should contain new value for the field
4: They fetched a field, now can either fetch a new field

9: New message from unknown number - we want to register a new patient
10: Patient texts back full name
11: Found a match, ask to confirm by texting birth date
12: No match :( Tell them to contact hospital?
13: Text back dob, either tell them its wrong and try again, or its
    a match, and we go to menu state 1

Here is the flowchart of menu states:





                |-1
       |-11--13-|
9--10--|        |-13
       |-12


           
     |-2-5
0--1-|-1
     |-3-4


so... RRSMS/Server.py receives an update
we know the full patient record, so should be sufficient
to save the rr_id, the field and new value
we can just shove those in a list of three-tuples
[(rr_id, field_name, new_value)] and pickle them 
somewhere for safe-keeping. 

Ideally, we'd have 1 SMS server, and multiple clients,
in order to allow them all to remain in sync on their own time,
one solution would be force them all to 'register' (details tbd),
so that the server could maintain seperate files of changes
for each one. So when some texts 'update dob of patient 100 to 1066'
or whatever, the SMS server would log that in each client's
file. When client A requests all the changes, we'd send it back
its file, and on receipt of an ACK, we could wipe it, but
not wipe client B's file so the data would still be there for it.

For the client-side, best thing is probably to just have a cron
job running a script to periodically fetch updates from the SMS
db. 

To further help keep things from getting out-of-whack in a dodgy
networking environment, it should be assumed some messages will
be lost. If the client never receives data, it never sends and
ACK and thats fine, it'll get it next time.
If the client receives data, but is unable to send an ACK, its
a slightly trickier problem. Basically, the server will not be 
able to wipe the data, so will send old updates to the client next
time, so we need the client to correct for this possibility.
We can put a timestamp in each transaction, and have the client
record the timestamp of the last transaction processed, so 
it can just ignore older ones if it reveives them. 